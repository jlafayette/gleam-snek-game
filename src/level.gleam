import gleam/int
import gleam/list
import gleam/option.{type Option, Some}
import gleam/string
import position.{type Move, type Pos, Down, Left, Pos, Right, Up}

pub const width = 20

pub const height = 15

const lvl_1 = "
.........E..........
....................
....................
....................
....................
....................
...................4
.....S>.............
....................
....................
....................
2...................
....................
....................
.........3.......1..
"

const lvl_2 = "
......2.............
....................
...................1
....S>..............
....................
....................
....................
...WWWWWWWWWWWWWW...
....................
...................4
....................
E...................
....................
....................
..................3.
"

const lvl_3 = "
4...................
....................
.....W........W.....
.....W........W.....
.....W........W....E
.....W........W.....
.....W........W.....
.....W........W.....
2....W........W.....
.....W........W.....
.....W....^...W.....
.....W....S...W.....
.....W........W.....
....................
1........3..........
"

const lvl_4 = "
.....2.............1
..S>................
....................
..WWWWWWWWWWWW......
....................
3...................
....................
......WWWWWWWWWWWW..
....................
....................
....................
..WWWWWWWWWWWW......
....................
...................E
......4.............
"

const lvl_5 = "
...2................
..S>................
....................
3....WWWWWWWWWW.....
....................
...W............W...
...W............W...
...W............W..E
...W............W...
...W............W...
....................
.....WWWWWWWWWW.....
....................
...................4
...1................
"

type Item {
  Wall(Pos)
  SnekInit(Pos)
  Dir(Move)
  ExitItem(Pos)
  SpawnItem(WallSpawn)
  Empty
}

type WallSpawn {
  WallSpawn(pos: Pos, order: Int)
}

type Acc =
  #(List(Pos), Option(Pos), Option(Move), Option(Pos), List(WallSpawn))

pub type Parsed {
  Parsed(
    number: Int,
    walls: List(Pos),
    snek_init: Pos,
    snek_dir: Move,
    exit_pos: Pos,
    spawns: List(Pos),
  )
}

fn collect_items(acc: Acc, item: Item) -> Acc {
  case item {
    Wall(pos) -> #([pos, ..acc.0], acc.1, acc.2, acc.3, acc.4)
    SnekInit(pos) -> #(acc.0, Some(pos), acc.2, acc.3, acc.4)
    Dir(move) -> #(acc.0, acc.1, Some(move), acc.3, acc.4)
    ExitItem(pos) -> #(acc.0, acc.1, acc.2, Some(pos), acc.4)
    SpawnItem(wall_spawn) -> #(acc.0, acc.1, acc.2, acc.3, [wall_spawn, ..acc.4])
    _ -> acc
  }
}

fn read_row(row: #(String, Int)) -> List(Item) {
  let #(line, y) = row
  line
  |> string.split("")
  |> list.map2(list.range(0, width), fn(char, x) {
    case char {
      "W" -> Wall(Pos(x, y))
      "S" -> SnekInit(Pos(x, y))
      "^" -> Dir(Up)
      ">" -> Dir(Right)
      "<" -> Dir(Left)
      "v" | "V" -> Dir(Down)
      "E" | "e" -> ExitItem(Pos(x, y))
      "1" -> SpawnItem(WallSpawn(Pos(x, y), 1))
      "2" -> SpawnItem(WallSpawn(Pos(x, y), 2))
      "3" -> SpawnItem(WallSpawn(Pos(x, y), 3))
      "4" -> SpawnItem(WallSpawn(Pos(x, y), 4))
      _ -> Empty
    }
  })
  |> list.filter(fn(x) { x != Empty })
}

fn read(n: Int, lvl: String) -> Parsed {
  let acc =
    lvl
    |> string.split("\n")
    |> list.filter(fn(x) { x != "" })
    |> list.map2(list.range(0, height), fn(line, y) { #(line, y) })
    |> list.map(fn(row) { read_row(row) })
    |> list.flatten
    |> list.fold(
      #([], Some(Pos(0, 0)), Some(Right), Some(Pos(0, 0)), []),
      collect_items,
    )
  case acc {
    #(walls, Some(init_pos), Some(dir), Some(exit), wall_spawn) -> {
      let spawn_positions =
        wall_spawn
        |> list.sort(fn(ws1, ws2) { int.compare(ws1.order, ws2.order) })
        |> list.map(fn(ws) { ws.pos })
      Parsed(
        number: n,
        walls: walls,
        snek_init: init_pos,
        snek_dir: dir,
        exit_pos: exit,
        spawns: spawn_positions,
      )
    }
    _ -> panic as "Bad level data"
  }
}

pub fn clamp(n: Int) -> Int {
  int.clamp(n, 1, 5)
}

pub fn get(n: Int) -> Parsed {
  case n {
    1 -> read(1, lvl_1)
    2 -> read(2, lvl_2)
    3 -> read(3, lvl_3)
    4 -> read(4, lvl_4)
    5 -> read(5, lvl_5)
    _ -> get(1)
  }
}
